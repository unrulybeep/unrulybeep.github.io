---
layout: post
title: "CSE143 Assignments"
---

[Course Webpage](https://courses.cs.washington.edu/courses/cse143/17sp)

[Homework Samples](https://courses.cs.washington.edu/courses/cse143/17sp/homework.shtml)

### Tiles
In this assignment you will write the logic for a graphical program that allows the user to click on rectangular tiles. When the TileMain class runs, it will create a graphical window on the screen; this is an object of type DrawingPanel. The panel displays a list of tiles. (Initially the panel shows 20 tiles, but you can add more by typing N.) Each tile is represented as an object of the provided class Tile. Each tile's position, size, and color are randomly generated by TileMain. You will write the TileManager to store and maintain a list of Tile objects. The graphical user interface ("GUI") displays the tiles and allows the user to manipulate them.
[Tile Manager Java file](/assets/smaples/cse143/hmwk1/TileManager.java)

### HTML Validator
This program focuses on using Stack and Queue collections. In this assignment you will write a class that examines HTML to figure out whether it represents "valid" sequences of tags.
[HTML Validator Java file](/assets/smaples/cse143/hmwk2/HtmlValidator.java)

### Assassin
You will write a class AssassinManager that keeps track of who is stalking whom and the history of who killed whom. You will maintain two linked lists: a list of people currently alive (the "kill ring") and a list of those who are dead (the "graveyard"). As people are killed, you will move them from the kill ring to the graveyard by rearranging links between nodes. The game ends when only one node remains in the kill ring, representing the winner.
[Assassin Manager Java file](/assets/smaples/cse143/hmwk3/AssassinManager.java)

### Evil Hangman
A normal game of hangman, the computer picks a word that the user is supposed to guess. The user then guesses individual letters until the word is fully discovered.

In our game of hangman, the computer delays picking a word until it is forced to. As a result, the computer is always considering a set of words that could be the answer. In order to fool the user into thinking it is playing fairly, the computer only considers words with the same letter pattern.

In a normal game of hangman, the computer would start the game by choosing a word to guess. In our game, the computer doesn't yet commit to an answer but instead narrows down its set of possible answers as the user makes guesses.
[Hangman Manager Java file](/assets/smaples/cse143/hmwk4/HangmanManager.java)

### Grammar Solver
You will write a class AssassinManager that keeps track of who is stalking whom and the history of who killed whom. You will maintain two linked lists: a list of people currently alive (the "kill ring") and a list of those who are dead (the "graveyard"). As people are killed, you will move them from the kill ring to the graveyard by rearranging links between nodes. The game ends when only one node remains in the kill ring, representing the winner.
[Grammar Solver Java file](/assets/smaples/cse143/hmwk5/GrammarSolver.java)

### Anagrams
You will create a class called Anagrams that uses a dictionary to find all anagram phrases that match a given word or phrase. You are provided with a client program AnagramMain that prompts the user for phrases and then passes those phrases to your Anagrams object. It asks your object to print all anagrams for those phrases.
[Anagrams Java file](/assets/smaples/cse143/hmwk6/Anagrams.java)

### 20 Questions
In this assignment you will implement a yes/no guessing game called "20 Questions." Each round of the game begins by you (the human player) thinking of an object. The computer will try to guess your object by asking you a series of yes or no questions. Eventually the computer will have asked enough questions that it thinks it knows what object you are thinking of. It will make a guess about what your object is. If this guess is correct, the computer wins; if not, you win.
[Question Tree Java file](/assets/smaples/cse143/hmwk7/QuestionTree.java)
[Question Node Java file](/assets/smaples/cse143/hmwk7/QuestionNode.java)

### Huffman Coding
This program provides practice with binary trees and priority queues.

#### Bonus
The main goal of this variation is to eliminate the code file. When you use a utility like zip, you don’t expect it to produce two output files (a code file and a binary file). You expect it to produce one file. That’s what we’ll do in this variation. To do so, we’ll have to be able to include information in the binary file about the tree and its structure.
[Huffman Tree Java file](/assets/smaples/cse143/hmwk8/HuffmanTree.java)
